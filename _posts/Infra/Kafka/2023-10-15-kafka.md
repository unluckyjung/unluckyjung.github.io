---
title: 카프카 조금 아는척 하기
date: 2023-10-22-23:22
categories: 
- Infra
- Kafka

tags:
- Kafka

---

## 카프카 조금 아는척 하기 강의 자료를 정리합니다.
> 최범균님의 카프카 조금 아는 척하기 유튜브 내용을 보고 정리합니다.

---

## 카프카란?
> 고성능 분산 이벤트 스트리밍 플랫폼

## 기본구조

![image](https://github.com/unluckyjung/unluckyjung.github.io/assets/43930419/5fd7f795-ade1-40f3-a738-8f7ebab1e0f9)


### 카프카 클러스터
> 메세지를 저장하는 역할을 하는 저장소

- N개의 브로커를 지니고 있음. 브로커는 각각의 하나씩의 서버라고 생각하면 됩니다.
- 이곳에서 메세지를 분산처리해서 저장하고, 장애가 난경우 처리하고 한다고 생각하면 됩니다.
- 데이터를 이동시키는데 핵심적인 역할을 하는 저장소 입니다.

### 주키퍼 클러스터
> 카프카 클러스터를 관리하는 역할

- 카프카 클러스터에 대한 정보를 가지고 있고 관리합니다.

### 프로듀서
> 메시지(이벤트) 를 카프카로 전송하는 역할을 합니다.

### 컨슈머
> 메시지(이벤트) 를 카프카로부터 읽는 역할을 합니다.

---

## 토픽과 파티션

![image](https://github.com/unluckyjung/unluckyjung.github.io/assets/43930419/fed99bf8-c791-43b9-a5ab-f8e4b27862e7)


### 토픽
> 메시지를 구분하는 단위 입니다.

- 브로커안에 토픽이 담기게 됩니다. 
- 토픽은 파일시스템에서의 폴더라고 생각하면 됩니다.
- 토픽안에서는 N개의 **파티션**을 지니고 있습니다.
- **파티션** 은 메시지를 저장하는 **물리적인 파일** 을 뜻합니다.
- 프로듀서와 컨슈머 입장에서는 토픽을 기준으로 메시지를 주고받게 되어집니다.


### 예시
- 음식 **토픽** (음식이라는 디렉토리, 얘 자체는 데이터를 가지고 있지 않음.)
  - 음식 **파티션1** (음식에 대한 실제 메시지 정보)
    - **컨슈머1** 는 여기서 메시지 정보를 얻어감.
  - 음식 파티션2 (음식에 대한 실제 메시지 정보)
    - 컨슈머2 는 여기서 메시지 정보를 얻어감.


### 파티션, 오프셋
> 파티션은 추가만 가능한 파일 (설정으로 인해서 삭제가 되게 할 수 도 있음, ex 일정 시간이 자닌뒤에 삭제를 하게됩니다.)


![image](https://github.com/unluckyjung/unluckyjung.github.io/assets/43930419/4f2377f9-5711-4a63-a6e5-41f9cb66bfb5)


- 오프셋: 메시지가 저장된 순서를 뜻함.
  - 3번 오프셋부터 데이터를 주세요 하면, 4번~6번의 데이터를 **순서대로** 읽어가게 됨.
  - 파일 상태이고 추가만 가능한 상태이기 때문에, 한개의 컨슈머에서 읽는 행위가, 다른 컨슈머에서 읽기 결과에 영향을 미치지 않음.

## 같은 토픽을 지닌 파티션이 N개인 경우

### 프로듀서와 파티션과의 관계
> 둘다 동일하게 topic이 1인 경우

![image](https://github.com/unluckyjung/unluckyjung.github.io/assets/43930419/a752c754-e6a9-4889-833c-807317513353)


- 기본설정으로는 라운드 로빈으로 번갈아면서 저장하게되어 집니다. (각각 저장되므로 순서보장 안됨)
- key 가 있다면, 해당 특정 파티션으로만 저장하게 되어집니다. (key 가 같다면 순서보장 됨)

### 파티션과 컨슈머와의 관계

![image](https://github.com/unluckyjung/unluckyjung.github.io/assets/43930419/50173b22-21be-4de9-8ec2-31e016e8f98b)

- 컨슈머는 그룹이라는곳에 항상 속해 있습니다.
- **그룹내에서 컨슈머는 같은 파티션에 연결할 수 없습니다.**
  - 컨슈머 A-1이 파티션 0번을 바라보고 있을때, 컨슈머 A-2는 파티션1을 바라볼 수 없습니다. (컨슈머 A-1, A-2 는 같은 그룹(A)이기 때문에 같은 파티션을 바라볼수 없음)
  - 컨슈머 B-1 은 파티션 0을 바라볼 수 있음. (다른 그룹이기 때문)
  - **이로 인해서, 한개의 컨슈머 그룹(예시 A) 에서는 파티션의 메시지가 순서대로 처리가 되는것이 보장되어 집니다.** (그룹내에서 여러개의 컨슈머가 한개의 파티션을 바라보는일이 없기 때문)
  - **헷갈리지 말점**: 한개의 파티션에 붙는것이 **다른 그룹**의 컨슈머인 경우, 한개의 파티션에 N개가 붙을 수 있음.

---

## 성능

- 파티션 파일에 대해서 **OS 페이지캐시**를 사용합니다.
  - 파티션에 대한 FILE IO 를 메모리단에서 처리하게 됩니다.
- Zero Copy
  - 디스크 버퍼에서 네트워크 버퍼로 직접 데이터 복사하여 처리하게 됩니다.
- 브로커가 하는일이 단순함
  - 컨슈머 추적을 위해서 크게 하는게 없습니다.
  - 메시지 필터, 메시지 재전송같은것은 브로커에서 하지않고, **프로듀서, 컨슈머가 직접 관리하기 떄문입니다.**
  - **브로커는 단순히 컨슈머와 파티션간의 매핑만 관리해줍니다.**
- 배치처리
  - `프로듀서 -> 카프카 <- 컨슈머` 관계에서 메시지를 여러개로 모아서 전송, 조회가 가능합니다.


## 확장성

![image](https://github.com/unluckyjung/unluckyjung.github.io/assets/43930419/78db8226-0877-4e0f-b1ba-57530dfaaee3)

- 카프카 클러스터가 **용량의 한계**에 다한경우
  - 브로커를 추가하고, 파티션을 추가해서 확장하면 됩니다.
  - 다른 파티션인경우에는 한개의 컨슈머가 전부다 조회가 가능합니다.
- 컨슈머가 **느려진 경우**
  - 컨슈머를 추가해주면 됩니다. 이때 같은 컨슈머 그룹에 추가된경우에는 같은 파티션을 볼 수 없으므로, 파티션도 추가해주는식으로 진행해야 합니다.

---

## 레플리카

![image](https://github.com/unluckyjung/unluckyjung.github.io/assets/43930419/c63fcd59-2c34-4119-95d0-1ba476bd0118)

- 레플리카를 만들게 된다면, 똑같은 파티션 정보를 가진채 다른 브로커에 저장이 되어집니다.
  - 토픽을 생성할때 레플리카 설정값이 2라면, 2개의 브로커가 추가적으로 생성되어 집니다.
  - 추가된것은 팔로워이고, 본체는 리더라고 명칭합니다.
  - 기본적으로는 리더를 통해서 메시지를 계속 처리합니다.
  - 팔로워는 리더로부터 계속 데이터를 복제해갑니다.
- 리더가 장애가난경우에는, 1개의 팔로워가 리더가되어 집니다.

---

## Reference
- https://youtu.be/0Ssx7jJJADI
